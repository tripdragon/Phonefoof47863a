<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ² Candy Board Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
  #canvas { display: block; width: 100vw; height: 100vh; }
  
  #joystick-container {
    position: fixed;
    bottom: 30px;
    right: 30px;
    width: 130px;
    height: 130px;
    user-select: none;
    z-index: 100;
  }
  #joystick-base {
    width: 130px;
    height: 130px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 3px solid rgba(255,255,255,0.4);
    backdrop-filter: blur(10px);
    position: relative;
    box-shadow: 0 0 30px rgba(255,200,100,0.3), inset 0 0 20px rgba(255,255,255,0.05);
  }
  #joystick-thumb {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #fff8b0, #ffaa00, #ff5500);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 4px 20px rgba(255,100,0,0.6), 0 0 0 3px rgba(255,200,50,0.5);
    transition: box-shadow 0.1s;
    pointer-events: none;
  }
  #joystick-container.active #joystick-thumb {
    box-shadow: 0 4px 30px rgba(255,150,0,0.9), 0 0 0 4px rgba(255,220,80,0.8);
  }

  #hud {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 22px;
    font-weight: 800;
    text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    letter-spacing: 2px;
    pointer-events: none;
    z-index: 100;
  }
  #hud span { color: #ffdd00; }

  #hint {
    position: fixed;
    bottom: 32px;
    left: 30px;
    color: rgba(255,255,255,0.55);
    font-size: 13px;
    pointer-events: none;
    z-index: 100;
    line-height: 1.7;
  }
  #hint kbd {
    background: rgba(255,255,255,0.15);
    border-radius: 4px;
    padding: 1px 6px;
    font-size: 12px;
    border: 1px solid rgba(255,255,255,0.3);
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="hud">ğŸ² CANDY BOARD &nbsp;|&nbsp; TILE <span id="tile-num">1</span></div>

<div id="joystick-container" id="joystick">
  <div id="joystick-base">
    <div id="joystick-thumb"></div>
  </div>
</div>

<div id="hint">
  ğŸ–±ï¸ Drag to orbit camera<br>
  ğŸ•¹ï¸ Joystick or <kbd>WASD</kbd> / <kbd>â†‘â†“â†â†’</kbd> to move
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€ SCENE SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 18, 22);
camera.lookAt(0, 0, 0);

// â”€â”€â”€ COLORFUL SKY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const skyGeo = new THREE.SphereGeometry(90, 32, 16);
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: { time: { value: 0 } },
  vertexShader: `
    varying vec3 vPos;
    void main() { vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.); }
  `,
  fragmentShader: `
    varying vec3 vPos;
    uniform float time;
    vec3 palette(float t) {
      vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5);
      vec3 c = vec3(1.,1.,1.),    d = vec3(0.0,0.33,0.67);
      return a + b*cos(6.28318*(c*t+d));
    }
    void main() {
      float y = normalize(vPos).y * 0.5 + 0.5;
      float t = y + time * 0.04;
      vec3 col = mix(palette(t), palette(t+0.3), smoothstep(0.2,0.8,y));
      gl_FragColor = vec4(col, 1.);
    }
  `
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// â”€â”€â”€ LIGHTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xfff0cc, 1.4);
sun.position.set(10, 20, 10);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 60;
sun.shadow.camera.left = sun.shadow.camera.bottom = -20;
sun.shadow.camera.right = sun.shadow.camera.top = 20;
scene.add(sun);

const colors = [0xff4d8b,0xff7f50,0xffd700,0x7cfc00,0x00cfff,0xbf5fff,0xff6eb4,0x00e5cc,0xffb347,0x87efff];

// â”€â”€â”€ GAME BOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BOARD_SIZE = 7;
const tiles = [];
const tilePositions = [];

// Spiral path around the board
function buildPath(n) {
  const path = [];
  let x = 0, z = 0, dx = 1, dz = 0;
  let steps = n - 1, stepCount = 0, turns = 0;
  path.push([0, 0]);
  for (let i = 0; i < (n*n - 1); i++) {
    x += dx; z += dz;
    path.push([x, z]);
    stepCount++;
    if (stepCount === steps) {
      [dx, dz] = [-dz, dx];
      turns++;
      stepCount = 0;
      if (turns % 2 === 0) steps--;
    }
  }
  return path;
}

const path = buildPath(BOARD_SIZE);
const tileSize = 1.6;
const gap = 0.15;
const step = tileSize + gap;
const offset = -((BOARD_SIZE - 1) * step) / 2;

// Board base
const baseGeo = new THREE.BoxGeometry(BOARD_SIZE * step + 1.2, 0.3, BOARD_SIZE * step + 1.2);
const baseMat = new THREE.MeshLambertMaterial({ color: 0x2d1b69 });
const base = new THREE.Mesh(baseGeo, baseMat);
base.position.y = -0.35;
base.receiveShadow = true;
scene.add(base);

// Grid tiles
for (let row = 0; row < BOARD_SIZE; row++) {
  for (let col = 0; col < BOARD_SIZE; col++) {
    const tileGeo = new THREE.BoxGeometry(tileSize, 0.2, tileSize);
    const colIdx = (row * BOARD_SIZE + col) % colors.length;
    const tileMat = new THREE.MeshLambertMaterial({ color: colors[colIdx] });
    const tile = new THREE.Mesh(tileGeo, tileMat);
    tile.position.set(offset + col * step, 0, offset + row * step);
    tile.receiveShadow = true;
    scene.add(tile);

    // Decorative dot
    const dotGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.05, 16);
    const dotMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
    const dot = new THREE.Mesh(dotGeo, dotMat);
    dot.position.set(offset + col * step, 0.13, offset + row * step);
    scene.add(dot);
  }
}

// Numbered path tiles with stars
path.forEach(([col, row], idx) => {
  const wx = offset + col * step;
  const wz = offset + row * step;
  tilePositions.push(new THREE.Vector3(wx, 0, wz));
  
  // Glow ring on path tiles
  const ringGeo = new THREE.TorusGeometry(tileSize * 0.42, 0.06, 8, 32);
  const ringMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.set(wx, 0.15, wz);
  ring.rotation.x = Math.PI / 2;
  scene.add(ring);
  tiles.push(ring);
});

// Star finish marker
function makeStar(x, z) {
  const group = new THREE.Group();
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2;
    const sGeo = new THREE.SphereGeometry(0.12, 8, 8);
    const sMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });
    const s = new THREE.Mesh(sGeo, sMat);
    s.position.set(Math.cos(a) * 0.45, 0.5, Math.sin(a) * 0.45);
    group.add(s);
  }
  const coreGeo = new THREE.SphereGeometry(0.2, 12, 12);
  const coreMat = new THREE.MeshLambertMaterial({ color: 0xff8800 });
  group.add(new THREE.Mesh(coreGeo, coreMat));
  group.position.set(x, 0.1, z);
  scene.add(group);
  return group;
}
const finishTile = tilePositions[tilePositions.length - 1];
const starMarker = makeStar(finishTile.x, finishTile.z);

// â”€â”€â”€ PLAYER PAWN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const pawnGroup = new THREE.Group();

// Body
const bodyGeo = new THREE.CylinderGeometry(0.28, 0.38, 0.7, 16);
const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff2288 });
pawnGroup.add(new THREE.Mesh(bodyGeo, bodyMat));

// Head
const headGeo = new THREE.SphereGeometry(0.32, 16, 16);
const headMat = new THREE.MeshLambertMaterial({ color: 0xff88cc });
const head = new THREE.Mesh(headGeo, headMat);
head.position.y = 0.7;
pawnGroup.add(head);

// Hat
const hatGeo = new THREE.ConeGeometry(0.22, 0.45, 16);
const hatMat = new THREE.MeshLambertMaterial({ color: 0x220055 });
const hat = new THREE.Mesh(hatGeo, hatMat);
hat.position.y = 1.05;
pawnGroup.add(hat);

// Hat brim
const brimGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.07, 16);
const brimMat = new THREE.MeshLambertMaterial({ color: 0x440088 });
const brim = new THREE.Mesh(brimGeo, brimMat);
brim.position.y = 0.85;
pawnGroup.add(brim);

// Star on hat
const hatStarGeo = new THREE.SphereGeometry(0.07, 8, 8);
const hatStarMat = new THREE.MeshLambertMaterial({ color: 0xffdd00 });
const hatStar = new THREE.Mesh(hatStarGeo, hatStarMat);
hatStar.position.set(0, 1.28, 0.18);
pawnGroup.add(hatStar);

pawnGroup.position.copy(tilePositions[0]);
pawnGroup.position.y = 0.15;
pawnGroup.castShadow = true;
scene.add(pawnGroup);

// Shadow circle under pawn
const shadowGeo = new THREE.CircleGeometry(0.4, 16);
const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
const pawnShadow = new THREE.Mesh(shadowGeo, shadowMat);
pawnShadow.rotation.x = -Math.PI / 2;
pawnShadow.position.y = 0.01;
scene.add(pawnShadow);

// â”€â”€â”€ FLOATING DECORATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floaters = [];
for (let i = 0; i < 18; i++) {
  const geoType = i % 3;
  let geo;
  if (geoType === 0) geo = new THREE.OctahedronGeometry(0.3 + Math.random() * 0.3);
  else if (geoType === 1) geo = new THREE.TetrahedronGeometry(0.28 + Math.random() * 0.25);
  else geo = new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 8, 8);
  
  const mat = new THREE.MeshLambertMaterial({ color: colors[i % colors.length], transparent: true, opacity: 0.85 });
  const mesh = new THREE.Mesh(geo, mat);
  const angle = (i / 18) * Math.PI * 2;
  const r = 9 + Math.random() * 4;
  mesh.position.set(Math.cos(angle) * r, 2 + Math.random() * 5, Math.sin(angle) * r);
  mesh.userData = { baseY: mesh.position.y, speed: 0.5 + Math.random(), phase: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 2 };
  scene.add(mesh);
  floaters.push(mesh);
}

// â”€â”€â”€ ORBIT CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let orbitTheta = 0.3, orbitPhi = 0.9, orbitRadius = 28;
let isDragging = false, prevX = 0, prevY = 0;

canvas.addEventListener('mousedown', e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  orbitTheta -= (e.clientX - prevX) * 0.01;
  orbitPhi = Math.max(0.2, Math.min(1.4, orbitPhi - (e.clientY - prevY) * 0.01));
  prevX = e.clientX; prevY = e.clientY;
});
window.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('wheel', e => {
  orbitRadius = Math.max(12, Math.min(50, orbitRadius + e.deltaY * 0.05));
});

// Touch orbit
canvas.addEventListener('touchstart', e => {
  if (e.target.closest('#joystick-container')) return;
  isDragging = true;
  prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
});
window.addEventListener('touchmove', e => {
  if (!isDragging) return;
  orbitTheta -= (e.touches[0].clientX - prevX) * 0.01;
  orbitPhi = Math.max(0.2, Math.min(1.4, orbitPhi - (e.touches[0].clientY - prevY) * 0.01));
  prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
});
window.addEventListener('touchend', () => isDragging = false);

// â”€â”€â”€ JOYSTICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const joyCon = document.getElementById('joystick-container');
const joyBase = document.getElementById('joystick-base');
const joyThumb = document.getElementById('joystick-thumb');
let joyInput = { x: 0, y: 0 };
let joyActive = false;

function getJoyCenter() {
  const r = joyBase.getBoundingClientRect();
  return { cx: r.left + r.width / 2, cy: r.top + r.height / 2, radius: r.width / 2 - 10 };
}

function updateJoy(clientX, clientY) {
  const { cx, cy, radius } = getJoyCenter();
  let dx = clientX - cx, dy = clientY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const clamp = Math.min(dist, radius);
  const angle = Math.atan2(dy, dx);
  const nx = Math.cos(angle) * clamp, ny = Math.sin(angle) * clamp;
  joyThumb.style.left = (50 + nx / joyBase.getBoundingClientRect().width * 100) + '%';
  joyThumb.style.top = (50 + ny / joyBase.getBoundingClientRect().height * 100) + '%';
  joyInput.x = nx / radius;
  joyInput.y = ny / radius;
}

function resetJoy() {
  joyThumb.style.left = '50%';
  joyThumb.style.top = '50%';
  joyInput = { x: 0, y: 0 };
  joyActive = false;
  joyCon.classList.remove('active');
}

joyBase.addEventListener('mousedown', e => { joyActive = true; joyCon.classList.add('active'); updateJoy(e.clientX, e.clientY); e.stopPropagation(); });
window.addEventListener('mousemove', e => { if (joyActive) updateJoy(e.clientX, e.clientY); });
window.addEventListener('mouseup', () => { if (joyActive) resetJoy(); });

joyBase.addEventListener('touchstart', e => { joyActive = true; joyCon.classList.add('active'); updateJoy(e.touches[0].clientX, e.touches[0].clientY); e.stopPropagation(); e.preventDefault(); }, { passive: false });
window.addEventListener('touchmove', e => { if (joyActive) { updateJoy(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); } }, { passive: false });
window.addEventListener('touchend', () => { if (joyActive) resetJoy(); });

// â”€â”€â”€ KEYBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; });
window.addEventListener('keyup', e => { keys[e.key] = false; });

// â”€â”€â”€ PLAYER MOVEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let playerTileIdx = 0;
let playerPos = tilePositions[0].clone();
let targetPos = tilePositions[0].clone();
let moving = false;
const MOVE_SPEED = 4.5;
let tileNum = document.getElementById('tile-num');
let moveTimer = 0;

function getInputDir() {
  let mx = joyInput.x, mz = joyInput.y;
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) mx -= 1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) mx += 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) mz -= 1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) mz += 1;
  return { mx, mz };
}

// â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const particles = [];
function spawnParticles(pos) {
  for (let i = 0; i < 8; i++) {
    const geo = new THREE.SphereGeometry(0.1, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    mesh.position.y += 0.5;
    const vel = new THREE.Vector3((Math.random()-0.5)*4, 2+Math.random()*3, (Math.random()-0.5)*4);
    scene.add(mesh);
    particles.push({ mesh, vel, life: 1 });
  }
}

// â”€â”€â”€ CLOCK & ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock = new THREE.Clock();
let elapsed = 0;

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  elapsed += dt;
  skyMat.uniforms.time.value = elapsed;

  // Floaters bob & spin
  floaters.forEach(f => {
    f.position.y = f.userData.baseY + Math.sin(elapsed * f.userData.speed + f.userData.phase) * 0.5;
    f.rotation.y += f.userData.rotSpeed * dt;
    f.rotation.x += f.userData.rotSpeed * 0.5 * dt;
  });

  // Star spin
  starMarker.rotation.y += dt * 1.2;
  starMarker.children.forEach((c, i) => {
    c.position.y = Math.abs(Math.sin(elapsed * 2 + i)) * 0.3 + 0.2;
  });

  // Tile ring pulse
  tiles.forEach((r, i) => {
    const scale = 1 + 0.06 * Math.sin(elapsed * 3 + i * 0.5);
    r.scale.set(scale, scale, scale);
  });

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= dt * 1.5;
    p.vel.y -= 6 * dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    p.mesh.material.opacity = p.life;
    p.mesh.material.transparent = true;
    if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
  }

  // Movement input
  const { mx, mz } = getInputDir();
  const inputLen = Math.sqrt(mx*mx + mz*mz);

  if (!moving && inputLen > 0.15) {
    moveTimer += dt;
    if (moveTimer > 0.15) {
      moveTimer = 0;
      // Find next tile in path direction
      // Use camera-relative direction
      const camForward = new THREE.Vector3(
        Math.sin(orbitTheta), 0, Math.cos(orbitTheta)
      );
      const camRight = new THREE.Vector3(
        Math.cos(orbitTheta), 0, -Math.sin(orbitTheta)
      );
      const moveDir = new THREE.Vector3()
        .addScaledVector(camRight, mx)
        .addScaledVector(camForward, -mz)
        .normalize();

      // Find closest valid neighbor tile
      let bestIdx = -1, bestDot = 0.3;
      tilePositions.forEach((tp, i) => {
        if (i === playerTileIdx) return;
        const d = tp.distanceTo(playerPos);
        if (d > step * 1.6) return;
        const dir = tp.clone().sub(playerPos).normalize();
        const dot = dir.dot(moveDir);
        if (dot > bestDot) { bestDot = dot; bestIdx = i; }
      });

      if (bestIdx >= 0) {
        targetPos = tilePositions[bestIdx].clone();
        playerTileIdx = bestIdx;
        moving = true;
        tileNum.textContent = playerTileIdx + 1;
        spawnParticles(playerPos);
      }
    }
  } else if (inputLen < 0.15) {
    moveTimer = 0;
  }

  if (moving) {
    playerPos.lerp(targetPos, Math.min(1, MOVE_SPEED * dt));
    if (playerPos.distanceTo(targetPos) < 0.03) {
      playerPos.copy(targetPos);
      moving = false;
    }
  }

  // Pawn bounce
  const bounce = Math.abs(Math.sin(elapsed * 6)) * (moving ? 0.25 : 0.08);
  pawnGroup.position.set(playerPos.x, 0.15 + bounce, playerPos.z);
  pawnGroup.rotation.y = elapsed * 1.5;
  pawnShadow.position.set(playerPos.x, 0.01, playerPos.z);
  pawnShadow.material.opacity = 0.3 - bounce * 0.3;

  // Orbit camera
  camera.position.set(
    pawnGroup.position.x + Math.sin(orbitTheta) * Math.cos(orbitPhi) * orbitRadius,
    Math.sin(orbitPhi) * orbitRadius,
    pawnGroup.position.z + Math.cos(orbitTheta) * Math.cos(orbitPhi) * orbitRadius
  );
  camera.lookAt(pawnGroup.position.x, 1, pawnGroup.position.z);

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>
