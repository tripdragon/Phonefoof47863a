<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Dice Ball Board Demo</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: radial-gradient(circle at top, #111827 0%, #020617 70%);
        color: #e2e8f0;
      }

      #app {
        position: fixed;
        inset: 0;
      }

      .hud {
        position: fixed;
        right: 1rem;
        top: 1rem;
        z-index: 10;
        padding: 0.7rem 1rem;
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.72);
        backdrop-filter: blur(8px);
        max-width: 420px;
      }

      .hud h1 {
        margin: 0 0 0.3rem;
        font-size: 1rem;
      }

      .hud p {
        margin: 0;
        font-size: 0.88rem;
        color: #cbd5e1;
      }

      .inset-frame {
        position: fixed;
        left: 1rem;
        top: 1rem;
        width: min(28vw, 330px);
        aspect-ratio: 16 / 10;
        border-radius: 12px;
        border: 2px solid rgba(99, 102, 241, 0.85);
        box-shadow: 0 10px 40px rgba(37, 99, 235, 0.32);
        pointer-events: none;
        z-index: 5;
      }
    </style>
  </head>
  <body>
    <div class="inset-frame" aria-hidden="true"></div>
    <div class="hud">
      <h1>Dice Ball Board Demo</h1>
      <p>Top-left camera shows dice packed in a glass ball and overlapping the view, built with superneatlib primitives.</p>
    </div>
    <div id="app"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
          "superneatlib": "/imported_scripts/superneatlib.min.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { Primitives } from "superneatlib";

      const container = document.getElementById("app");

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050b18);
      scene.fog = new THREE.Fog(0x050b18, 10, 34);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.autoClear = false;
      container.appendChild(renderer.domElement);

      const mainCamera = new THREE.PerspectiveCamera(58, window.innerWidth / window.innerHeight, 0.1, 100);
      mainCamera.position.set(6.2, 6.4, 7.3);

      const topLeftCamera = new THREE.PerspectiveCamera(64, 16 / 10, 0.05, 100);
      topLeftCamera.position.set(-0.5, 2.2, 2.05);

      const controls = new OrbitControls(mainCamera, renderer.domElement);
      controls.target.set(0, 0.45, 0);
      controls.enableDamping = true;
      controls.maxDistance = 18;
      controls.minDistance = 4;
      controls.maxPolarAngle = Math.PI * 0.49;

      scene.add(new THREE.HemisphereLight(0x8ec5ff, 0x1f2937, 0.72));

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
      keyLight.position.set(8, 12, 4);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(2048, 2048);
      keyLight.shadow.camera.left = -8;
      keyLight.shadow.camera.right = 8;
      keyLight.shadow.camera.top = 8;
      keyLight.shadow.camera.bottom = -8;
      scene.add(keyLight);

      const floor = new THREE.Mesh(
        new THREE.CircleGeometry(18, 96),
        new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.96, metalness: 0.05 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.75;
      floor.receiveShadow = true;
      scene.add(floor);

      const board = new THREE.Group();
      scene.add(board);

      const boardBase = Primitives.cube({ color: 0x1d4ed8 });
      boardBase.scale.set(7, 0.4, 7);
      boardBase.material = new THREE.MeshStandardMaterial({
        color: 0x1d4ed8,
        roughness: 0.52,
        metalness: 0.18,
        emissive: 0x102a65,
        emissiveIntensity: 0.35,
      });
      boardBase.position.y = -0.22;
      boardBase.castShadow = true;
      boardBase.receiveShadow = true;
      board.add(boardBase);

      const tileMats = [
        new THREE.MeshStandardMaterial({ color: 0xf472b6, roughness: 0.58, metalness: 0.17 }),
        new THREE.MeshStandardMaterial({ color: 0x22d3ee, roughness: 0.56, metalness: 0.2 }),
      ];
      const size = 8;
      const spacing = 0.8;
      const edgeOffset = ((size - 1) * spacing) / 2;
      for (let row = 0; row < size; row += 1) {
        for (let col = 0; col < size; col += 1) {
          const tile = Primitives.cube({ color: 0xffffff });
          tile.scale.set(0.78, 0.1, 0.78);
          tile.material = tileMats[(row + col) % 2];
          tile.position.set(col * spacing - edgeOffset, 0.05, row * spacing - edgeOffset);
          tile.receiveShadow = true;
          board.add(tile);
        }
      }

      const diceGroup = new THREE.Group();
      board.add(diceGroup);
      diceGroup.position.set(-0.85, 1.1, 1.3);

      const dieMaterial = new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.34, metalness: 0.06, emissive: 0x111827, emissiveIntensity: 0.2 });

      const dice = [];
      const diceCount = 24;
      for (let i = 0; i < diceCount; i += 1) {
        const die = Primitives.cube({ color: 0xffffff });
        die.scale.setScalar(0.28);
        die.material = dieMaterial;
        const phi = Math.acos(1 - 2 * ((i + 0.3) / diceCount));
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        const radius = 0.62 + Math.sin(i * 2.4) * 0.08;
        die.position.set(
          Math.cos(theta) * Math.sin(phi) * radius,
          Math.cos(phi) * radius,
          Math.sin(theta) * Math.sin(phi) * radius
        );
        die.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        die.castShadow = true;
        diceGroup.add(die);
        dice.push(die);
      }

      const glassBall = Primitives.ball({ color: 0x93c5fd, scale: 0.92 });
      glassBall.material = new THREE.MeshPhysicalMaterial({
          color: 0x93c5fd,
          transmission: 0.8,
          thickness: 0.38,
          roughness: 0.08,
          metalness: 0.02,
          transparent: true,
          opacity: 0.45,
          clearcoat: 0.9,
          clearcoatRoughness: 0.14,
        });
      glassBall.castShadow = true;
      glassBall.receiveShadow = true;
      diceGroup.add(glassBall);

      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(3.1, 0.09, 20, 90),
        new THREE.MeshStandardMaterial({ color: 0x6366f1, roughness: 0.36, metalness: 0.52, emissive: 0x1e1b4b, emissiveIntensity: 0.35 })
      );
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.03;
      board.add(ring);

      const clock = new THREE.Clock();

      function render() {
        const t = clock.getElapsedTime();

        board.rotation.y = Math.sin(t * 0.35) * 0.12;
        ring.rotation.z = Math.sin(t * 0.45) * 0.2;
        diceGroup.rotation.y = t * 0.65;
        diceGroup.rotation.x = Math.sin(t * 0.8) * 0.22;

        dice.forEach((die, idx) => {
          die.rotation.x += 0.012 + idx * 0.00008;
          die.rotation.y += 0.015 + idx * 0.00006;
        });

        topLeftCamera.position.x = -0.48 + Math.sin(t * 1.2) * 0.18;
        topLeftCamera.position.y = 2.22 + Math.cos(t * 1.1) * 0.12;
        topLeftCamera.position.z = 2.04 + Math.cos(t * 0.9) * 0.15;
        topLeftCamera.lookAt(diceGroup.getWorldPosition(new THREE.Vector3()));

        controls.update();

        renderer.clear();
        renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
        renderer.setScissorTest(false);
        renderer.render(scene, mainCamera);

        const insetWidth = Math.min(window.innerWidth * 0.28, 330);
        const insetHeight = insetWidth * (10 / 16);
        const insetX = 16;
        const insetY = window.innerHeight - insetHeight - 16;

        renderer.clearDepth();
        renderer.setScissorTest(true);
        renderer.setScissor(insetX, insetY, insetWidth, insetHeight);
        renderer.setViewport(insetX, insetY, insetWidth, insetHeight);
        renderer.render(scene, topLeftCamera);

        requestAnimationFrame(render);
      }

      function onResize() {
        mainCamera.aspect = window.innerWidth / window.innerHeight;
        mainCamera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener("resize", onResize);
      render();
    </script>
  </body>
</html>
