<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Mini Game Board</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: radial-gradient(circle at top, #0f172a 0%, #020617 70%);
        color: #e2e8f0;
      }

      #app {
        position: fixed;
        inset: 0;
      }

      .hud {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 10;
        display: grid;
        gap: 0.4rem;
        padding: 0.8rem 1rem;
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.68);
        backdrop-filter: blur(8px);
        max-width: min(90vw, 420px);
      }

      .hud h1 {
        margin: 0;
        font-size: 1rem;
      }

      .hud p {
        margin: 0;
        font-size: 0.88rem;
        color: #cbd5e1;
      }
    </style>
  </head>
  <body>
    <div class="hud">
      <h1>Mini Game Board Scene</h1>
      <p>Orbit to inspect the board, towers, and moving game token.</p>
    </div>
    <div id="app" aria-hidden="true"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const container = document.getElementById("app");

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x060d1f);
      scene.fog = new THREE.Fog(0x060d1f, 16, 30);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(5.2, 6.2, 6.8);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0.2, 0);
      controls.minDistance = 4;
      controls.maxDistance = 16;
      controls.maxPolarAngle = Math.PI * 0.48;

      const ambient = new THREE.HemisphereLight(0x9ecbff, 0x1a294a, 0.65);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.2);
      sun.position.set(7, 11, 5);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -8;
      sun.shadow.camera.right = 8;
      sun.shadow.camera.top = 8;
      sun.shadow.camera.bottom = -8;
      scene.add(sun);

      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(14, 96),
        new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.96, metalness: 0.05 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.7;
      ground.receiveShadow = true;
      scene.add(ground);

      const boardGroup = new THREE.Group();
      scene.add(boardGroup);

      const boardBase = new THREE.Mesh(
        new THREE.BoxGeometry(6, 0.35, 6),
        new THREE.MeshStandardMaterial({ color: 0x2d1b0f, roughness: 0.8, metalness: 0.12 })
      );
      boardBase.position.y = -0.2;
      boardBase.castShadow = true;
      boardBase.receiveShadow = true;
      boardGroup.add(boardBase);

      const tileGeometry = new THREE.BoxGeometry(0.72, 0.08, 0.72);
      const lightTile = new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.75, metalness: 0.08 });
      const darkTile = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.75, metalness: 0.1 });

      const boardSize = 6;
      const offset = (boardSize - 1) * 0.38;

      for (let row = 0; row < boardSize; row += 1) {
        for (let col = 0; col < boardSize; col += 1) {
          const tile = new THREE.Mesh(tileGeometry, (row + col) % 2 === 0 ? lightTile : darkTile);
          tile.position.set(col * 0.76 - offset, 0.03, row * 0.76 - offset);
          tile.receiveShadow = true;
          boardGroup.add(tile);
        }
      }

      const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.45, metalness: 0.35 });
      const towerTopMaterial = new THREE.MeshStandardMaterial({ color: 0xc4b5fd, roughness: 0.3, metalness: 0.4 });

      const corners = [
        [-2.45, -2.45],
        [2.45, -2.45],
        [-2.45, 2.45],
        [2.45, 2.45],
      ];

      corners.forEach(([x, z]) => {
        const tower = new THREE.Group();

        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.23, 0.27, 1, 20), towerMaterial);
        stem.position.y = 0.45;
        stem.castShadow = true;
        tower.add(stem);

        const top = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.2, 20), towerTopMaterial);
        top.position.y = 1.05;
        top.castShadow = true;
        tower.add(top);

        tower.position.set(x, 0, z);
        boardGroup.add(tower);
      });

      const token = new THREE.Mesh(
        new THREE.SphereGeometry(0.24, 32, 24),
        new THREE.MeshStandardMaterial({ color: 0xf97316, roughness: 0.35, metalness: 0.32, emissive: 0x57290f })
      );
      token.position.set(-1.9, 0.32, -1.9);
      token.castShadow = true;
      boardGroup.add(token);

      const tokenPath = [
        new THREE.Vector3(-1.9, 0.32, -1.9),
        new THREE.Vector3(-1.14, 0.32, -1.14),
        new THREE.Vector3(-0.38, 0.32, -0.38),
        new THREE.Vector3(0.38, 0.32, 0.38),
        new THREE.Vector3(1.14, 0.32, 1.14),
        new THREE.Vector3(1.9, 0.32, 1.9),
      ];

      const accentRing = new THREE.Mesh(
        new THREE.TorusGeometry(2.72, 0.08, 12, 80),
        new THREE.MeshStandardMaterial({ color: 0x0ea5e9, roughness: 0.35, metalness: 0.5 })
      );
      accentRing.rotation.x = Math.PI / 2;
      accentRing.position.y = 0.01;
      accentRing.receiveShadow = true;
      boardGroup.add(accentRing);

      const clock = new THREE.Clock();

      function animate() {
        const t = clock.getElapsedTime();

        const segment = Math.floor((t * 0.7) % (tokenPath.length - 1));
        const lerpT = (t * 0.7) % 1;
        token.position.lerpVectors(tokenPath[segment], tokenPath[segment + 1], lerpT);
        token.position.y = 0.32 + Math.sin(t * 4) * 0.05;

        token.rotation.y += 0.02;
        accentRing.rotation.z = Math.sin(t * 0.5) * 0.16;
        boardGroup.rotation.y = Math.sin(t * 0.35) * 0.15;

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener("resize", onResize);
      animate();
    </script>
  </body>
</html>
